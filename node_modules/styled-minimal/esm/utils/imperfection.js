import { getPercentage, getRandomInt, isNumber, limitNumber } from './helpers';
export function convertToNumber(input) {
    if (typeof input === 'number') {
        return input;
    }
    return input
        .split('')
        .map(function (d) { return d.charCodeAt(0); })
        .reduce(function (a, b) { return a + b; }, 0);
}
export function generateCircle(amount, randomize) {
    if (amount === void 0) { amount = 0; }
    if (randomize === void 0) { randomize = false; }
    var leftCurvePoint = '57.307552';
    var rightCurvePoint = '198.692448';
    var direction = function () { return (randomize ? getOneOf('clockwise', 'counter-clockwise') : 'clockwise'); };
    var variance = function () { return (amount && randomize ? amount + getRandomInt(-3, 3) : amount); };
    var _a = getCurveSkew(256, variance(), direction()), bf = _a[0], bb = _a[1];
    var _b = getCurveSkew(256, variance(), direction()), rf = _b[0], rb = _b[1];
    var _c = getCurveSkew(0, variance(), direction()), tf = _c[0], tb = _c[1];
    var _d = getCurveSkew(0, variance(), direction()), lf = _d[0], lb = _d[1];
    var quarters = {
        bottom: "M128,256",
        bottomForward: "C" + rightCurvePoint + "," + bf,
        rightBackward: rb + "," + rightCurvePoint,
        right: "256,128",
        rightForward: "C" + rf + "," + leftCurvePoint,
        topBackward: rightCurvePoint + "," + tb,
        top: "128,0",
        topForward: "C" + leftCurvePoint + "," + tf,
        leftBackward: lb + "," + leftCurvePoint,
        left: "0,128",
        leftForward: "C" + lf + "," + rightCurvePoint,
        bottomBackward: leftCurvePoint + "," + bb,
        lastPath: "128,256",
        close: "Z",
    };
    return Object.values(quarters).join(' ');
}
export function getCurveSkew(value, amount, direction) {
    if (amount === void 0) { amount = 0; }
    if (direction === void 0) { direction = 'clockwise'; }
    var nextAmount = amount;
    var plus = value + nextAmount;
    var minus = value - nextAmount;
    var clockwise = direction === 'clockwise';
    var left = clockwise ? plus : minus;
    var right = clockwise ? minus : plus;
    return [left, right];
}
export function getRandomBoolean(ratio) {
    if (ratio === void 0) { ratio = 0.4; }
    return Math.random() >= ratio;
}
export function getOneOf(inputA, inputB, ratio) {
    if (ratio === void 0) { ratio = 0.4; }
    return getRandomBoolean(ratio) ? inputA : inputB;
}
export function scale(input, inputRange, masterRange) {
    var min = masterRange[0], max = masterRange[1];
    var iMin = inputRange[0], iMax = inputRange[1];
    var percent = (input - iMin) / (iMax - iMin);
    var value = percent * (max - min) + min;
    var nextValue = value < min ? min : value;
    return value > max ? max : nextValue;
}
export function unique(seed) {
    if (seed === void 0) { seed = 'wabi-sabi'; }
    var num = (convertToNumber(seed) * 16807) % 0.92123;
    if (num <= 0) {
        num += 0.232123;
    }
    return num;
}
var Imperfection = /** @class */ (function () {
    function Imperfection(seed, xMax, yMax) {
        if (xMax === void 0) { xMax = 260; }
        if (yMax === void 0) { yMax = 60; }
        this.count = 0;
        this.boundaries = {
            top: 0,
            left: 0,
            right: xMax,
            bottom: yMax,
        };
        this.seed = seed;
        this.xMax = xMax;
        this.yMax = yMax;
    }
    Imperfection.prototype.getMax = function (value) {
        return value <= this.yMax ? this.yMax : this.xMax;
    };
    Imperfection.prototype.getPath = function (mutation, complexity, asPercentage) {
        var _this = this;
        if (asPercentage === void 0) { asPercentage = true; }
        var points = limitNumber(Number(complexity), 0, 30);
        var limit = scale(Number(mutation), [0, 10], [0, 5]);
        var divisions = Math.round(this.xMax / (points + 1));
        var output = [];
        this.count = 0;
        output.push(this.getPoint('top', 'left', limit));
        if (points) {
            for (var i = 0; i < points; i++) {
                var base = divisions * (i + 1);
                output.push(this.getPoint(this.getRandomInt(limitNumber(base - 8, 0, this.xMax), limitNumber(base + 8, 0, this.xMax)), 'top', limit));
            }
        }
        output.push(this.getPoint('right', 'top', limit));
        output.push(this.getPoint('right', 'bottom', limit));
        if (points) {
            for (var i = points; i > 0; i--) {
                var base = divisions * (i - 1);
                output.push(this.getPoint(this.getRandomInt(limitNumber(base - 8, 0, this.xMax), limitNumber(base + 8, 0, this.xMax)), 'bottom', limit));
            }
        }
        output.push(this.getPoint('left', 'bottom', limit));
        if (asPercentage) {
            return output
                .map(function (d) {
                var _a = d.split(' ').map(Number), p1 = _a[0], right = _a[1];
                return getPercentage(p1, _this.xMax) + "% " + getPercentage(right, _this.yMax) + "%";
            })
                .join(', ');
        }
        return output.join(' ');
    };
    Imperfection.prototype.getPoint = function (xPos, yPos, limit) {
        var left = isNumber(xPos) ? xPos : this.boundaries[xPos];
        var right = isNumber(yPos) ? yPos : this.boundaries[yPos];
        if (limit === 0) {
            return left + " " + right;
        }
        var p1 = this.getRandomInt(left === this.xMax ? left - 5 : left, limitNumber(left + limit, 0, this.getMax(left)));
        var p2 = this.getRandomInt(limitNumber(right - limit, 0, this.getMax(right)), limitNumber(right + limit, 0, this.getMax(right)));
        return p1 + " " + p2;
    };
    Imperfection.prototype.getRandomInt = function (min, max) {
        this.count++;
        return getRandomInt(min, max, unique("" + this.seed + this.count));
    };
    return Imperfection;
}());
export { Imperfection };
//# sourceMappingURL=imperfection.js.map