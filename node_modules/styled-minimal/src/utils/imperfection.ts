import { getPercentage, getRandomInt, isNumber, limitNumber } from './helpers';

import { NumberOrString } from '../types';

export function convertToNumber(input: NumberOrString) {
  if (typeof input === 'number') {
    return input;
  }

  return input
    .split('')
    .map((d: string) => d.charCodeAt(0))
    .reduce((a: number, b: number) => a + b, 0);
}

export function generateCircle(amount = 0, randomize = false) {
  const leftCurvePoint = '57.307552';
  const rightCurvePoint = '198.692448';
  const direction = () => (randomize ? getOneOf('clockwise', 'counter-clockwise') : 'clockwise');
  const variance = () => (amount && randomize ? amount + getRandomInt(-3, 3) : amount);

  const [bf, bb] = getCurveSkew(256, variance(), direction());
  const [rf, rb] = getCurveSkew(256, variance(), direction());
  const [tf, tb] = getCurveSkew(0, variance(), direction());
  const [lf, lb] = getCurveSkew(0, variance(), direction());

  const quarters = {
    bottom: `M128,256`,
    bottomForward: `C${rightCurvePoint},${bf}`,
    rightBackward: `${rb},${rightCurvePoint}`,
    right: `256,128`,
    rightForward: `C${rf},${leftCurvePoint}`,
    topBackward: `${rightCurvePoint},${tb}`,
    top: `128,0`,
    topForward: `C${leftCurvePoint},${tf}`,
    leftBackward: `${lb},${leftCurvePoint}`,
    left: `0,128`,
    leftForward: `C${lf},${rightCurvePoint}`,
    bottomBackward: `${leftCurvePoint},${bb}`,
    lastPath: `128,256`,
    close: `Z`,
  };

  return Object.values(quarters).join(' ');
}

export function getCurveSkew(value: number, amount = 0, direction = 'clockwise') {
  const nextAmount = amount;
  const plus = value + nextAmount;
  const minus = value - nextAmount;
  const clockwise = direction === 'clockwise';

  const left = clockwise ? plus : minus;
  const right = clockwise ? minus : plus;

  return [left, right];
}

export function getRandomBoolean(ratio = 0.4) {
  return Math.random() >= ratio;
}

export function getOneOf(inputA: any, inputB: any, ratio = 0.4) {
  return getRandomBoolean(ratio) ? inputA : inputB;
}

export function scale(input: number, inputRange: [number, number], masterRange: [number, number]) {
  const [min, max] = masterRange;
  const [iMin, iMax] = inputRange;

  const percent = (input - iMin) / (iMax - iMin);
  const value = percent * (max - min) + min;
  const nextValue = value < min ? min : value;

  return value > max ? max : nextValue;
}

export function unique(seed = 'wabi-sabi') {
  let num = (convertToNumber(seed) * 16807) % 0.92123;

  if (num <= 0) {
    num += 0.232123;
  }

  return num;
}

export class Imperfection {
  boundaries: any;
  count = 0;
  seed: NumberOrString;
  xMax: number;
  yMax: number;

  constructor(seed: NumberOrString, xMax = 260, yMax = 60) {
    this.boundaries = {
      top: 0,
      left: 0,
      right: xMax,
      bottom: yMax,
    };

    this.seed = seed;
    this.xMax = xMax;
    this.yMax = yMax;
  }

  private getMax(value: number) {
    return value <= this.yMax ? this.yMax : this.xMax;
  }

  public getPath(mutation: number, complexity: number, asPercentage = true) {
    const points = limitNumber(Number(complexity), 0, 30);
    const limit = scale(Number(mutation), [0, 10], [0, 5]);
    const divisions = Math.round(this.xMax / (points + 1));

    const output: string[] = [];
    this.count = 0;

    output.push(this.getPoint('top', 'left', limit));

    if (points) {
      for (let i = 0; i < points; i++) {
        const base = divisions * (i + 1);

        output.push(
          this.getPoint(
            this.getRandomInt(
              limitNumber(base - 8, 0, this.xMax),
              limitNumber(base + 8, 0, this.xMax),
            ),
            'top',
            limit,
          ),
        );
      }
    }

    output.push(this.getPoint('right', 'top', limit));
    output.push(this.getPoint('right', 'bottom', limit));

    if (points) {
      for (let i = points; i > 0; i--) {
        const base = divisions * (i - 1);

        output.push(
          this.getPoint(
            this.getRandomInt(
              limitNumber(base - 8, 0, this.xMax),
              limitNumber(base + 8, 0, this.xMax),
            ),
            'bottom',
            limit,
          ),
        );
      }
    }

    output.push(this.getPoint('left', 'bottom', limit));

    if (asPercentage) {
      return output
        .map((d) => {
          const [p1, right] = d.split(' ').map(Number);

          return `${getPercentage(p1, this.xMax)}% ${getPercentage(right, this.yMax)}%`;
        })
        .join(', ');
    }

    return output.join(' ');
  }

  private getPoint(xPos: NumberOrString, yPos: NumberOrString, limit: number) {
    const left = isNumber(xPos) ? xPos : this.boundaries[xPos];
    const right = isNumber(yPos) ? yPos : this.boundaries[yPos];

    if (limit === 0) {
      return `${left} ${right}`;
    }

    const p1 = this.getRandomInt(
      left === this.xMax ? left - 5 : left,
      limitNumber(left + limit, 0, this.getMax(left)),
    );

    const p2 = this.getRandomInt(
      limitNumber(right - limit, 0, this.getMax(right)),
      limitNumber(right + limit, 0, this.getMax(right)),
    );

    return `${p1} ${p2}`;
  }

  private getRandomInt(min: number, max: number) {
    this.count++;

    return getRandomInt(min, max, unique(`${this.seed}${this.count}`));
  }
}
