import {
  css,
  CSSObject,
  FlattenInterpolation,
  FlattenSimpleInterpolation,
  ThemedStyledProps,
} from 'styled-components';
import systemCSS from '@styled-system/css';

import {
  getColor,
  getDarkColor,
  getAccentColor,
  getMutation,
  getProps,
  getTextColor,
  getTheme,
  isDefined,
  px,
  responsive,
} from './helpers';
import { Imperfection } from './imperfection';
import { placeholder } from './mixins';
import { darken, desaturate, lighten } from './polished';
import { styleSystem } from './styles';

import { CommonProps, InputTypes } from '../types';

interface MutationOptions {
  skipTheme: boolean;
}

export const inputTextTypes: InputTypes[] = [
  'date',
  'email',
  'file',
  'number',
  'password',
  'search',
  'tel',
  'text',
];

export const appearanceStyles: CSSObject = {
  appearance: 'none',
};

export const baseStyles: CSSObject = {
  boxSizing: 'border-box',
};

export function colorStyles(props: CommonProps): FlattenSimpleInterpolation {
  const { dark, invert } = props;

  return css`
    color: ${invert || dark ? getColor(props) : getTextColor(props)};
  `;
}

export function lineHeightStyles(props: CommonProps): number {
  return getTheme(props, 'lineHeight');
}

export function mutationStyles(
  options?: MutationOptions,
): (props: CommonProps) => FlattenSimpleInterpolation {
  const { skipTheme = false } = options || {};

  return (props) => {
    const { complexity, height, mutation, seed, width } = getMutation(props, skipTheme);

    if (!mutation || props.type === 'color') {
      return css``;
    }

    const shape = new Imperfection(seed || '', width, height);
    const path = shape.getPath(mutation, complexity ?? 0, true);

    return css`
      -webkit-appearance: none;
      -webkit-clip-path: polygon(${path});
      border: 0;
      clip-path: polygon(${path});
      transition: clip-path 0.5s;
    `;
  };
}

export function inputStyles(props: CommonProps): FlattenInterpolation<ThemedStyledProps<any, any>> {
  const {
    invert,
    multiple,
    outline,
    outlineColor,
    outlineOffset = 1,
    outlineStyle,
    outlineWidth,
    type,
    valid,
  } = props;
  let elementType: 'input' | 'select' | 'textarea' = 'input';

  if (isDefined(multiple)) {
    elementType = 'select';
  } else if (!isDefined(type)) {
    elementType = 'textarea';
  }

  const {
    backgroundColor,
    borderColor,
    checkedBgColor,
    color,
    disabledColor,
    requiredColor,
    validation,
  } = getTheme(props, elementType);
  const primaryColor = getColor(props);

  const currentBgColor = backgroundColor;
  const currentColor = color;
  let currentBorderColor = borderColor;
  const multipleCheckedBgColor = checkedBgColor || getAccentColor(primaryColor, true);

  if (valid) {
    currentBorderColor = validation.valid;
  } else if (valid === false) {
    currentBorderColor = validation.invalid;
  }

  return css`
    ${placeholder(`color: ${lighten(0.5, currentColor)};`)};

    &:focus {
      ${outline ? `outline: ${outline}` : null};
      outline-color: ${outlineColor || (invert ? currentBorderColor : color)};
      ${outlineOffset ? `outline-offset: ${px(outlineOffset)}` : null};
      ${outlineStyle ? `outline-style: ${outlineStyle}` : null};
      ${outlineWidth ? `outline-width: ${px(outlineWidth)}` : null};
    }

    &[multiple] {
      > option {
        &:not(:checked) {
          background: ${`${currentBgColor} linear-gradient(0deg, ${currentBgColor} 0%, ${currentBgColor} 100%)`};
        }

        &:checked {
          background: ${`${multipleCheckedBgColor} linear-gradient(0deg, ${multipleCheckedBgColor} 0%, ${multipleCheckedBgColor} 100%)`};
          font-weight: bold;
        }
      }
    }

    &:disabled {
      background-color: ${disabledColor};
      border-color: ${disabledColor};
      color: ${lighten(0.3, currentColor)};

      &:not([multiple]) > option {
        background-color: ${disabledColor};

        &:checked {
          opacity: 0.7;
        }
      }
    }

    &:required:not(:valid) {
      border-color: ${requiredColor};
      ${placeholder(`color: ${lighten(0.1, desaturate(0.2, requiredColor))};`)};
    }

    ${type &&
    `
      &:read-only {
        background-color: ${darken(0.02, backgroundColor)};
        color: ${lighten(0.3, currentColor)};
        cursor: not-allowed;
      }
    `}
  `;
}

export function sx(props: any) {
  const mergedProps = getProps(props);

  return {
    ...systemCSS(props.css)(mergedProps),
    ...responsive(props.responsive)(mergedProps)(),
  };
}

export function system(props: any) {
  return styleSystem(getProps(props));
}

export function variantStyles(props: CommonProps): FlattenSimpleInterpolation {
  const { dark, invert, transparent } = props;
  const { darkColor } = getTheme(props);
  const themeColor = getColor(props);

  const backgroundColor = invert ? '#fff' : themeColor;
  const color = invert ? themeColor : getTextColor(props);

  if (transparent) {
    return css`
      background-color: transparent;
      border: 0;
      color: ${color};
    `;
  }

  return css`
    background-color: ${dark ? darkColor : backgroundColor};
    border: ${`1px solid ${dark ? darkColor : themeColor}`};
    color: ${dark ? getDarkColor(props) : color};
  `;
}
