var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import is from 'is-lite';
/**
 * Get a random item from an array
 */
export function getRandomItem(input) {
    return input[Math.floor(Math.random() * input.length)];
}
/**
 * Sort an array of numbers using a quick sort algorithm
 */
export function quickSort(input, comparator) {
    if (comparator === void 0) { comparator = sortComparator; }
    // Create a sortable array to return.
    var output = __spreadArray([], __read(input), false);
    // Recursively sort sub-arrays.
    var recursiveSort = function (start, end) {
        // If this sub-array is empty, it's sorted.
        if (end - start < 1) {
            return;
        }
        var pivotValue = output[end];
        var splitIndex = start;
        for (var index = start; index < end; index++) {
            var sort = comparator(output[index], pivotValue);
            // This value is less than the pivot value.
            if (sort === -1) {
                // If the element just to the right of the split index,
                //   isn't this element, swap them.
                if (splitIndex !== index) {
                    var temp = output[splitIndex];
                    output[splitIndex] = output[index];
                    output[index] = temp;
                }
                // Move the split index to the right by one,
                //   denoting an increase in the less-than sub-array size.
                splitIndex++;
            }
            // Leave values that are greater than or equal to
            //   the pivot value where they are.
        }
        // Move the pivot value to between the split.
        output[end] = output[splitIndex];
        output[splitIndex] = pivotValue;
        // Recursively sort the less-than and greater-than arrays.
        recursiveSort(start, splitIndex - 1);
        recursiveSort(splitIndex + 1, end);
    };
    // Sort the entire array.
    recursiveSort(0, input.length - 1);
    return output;
}
/**
 * Sort an array with localeCompare
 */
export function sortByLocaleCompare(key, options) {
    if (options === void 0) { options = {}; }
    var descending = options.descending, compareOptions = __rest(options, ["descending"]);
    if (key) {
        if (descending) {
            return function (left, right) {
                return right[key].toLowerCase().localeCompare(left[key].toLowerCase(), undefined, compareOptions);
            };
        }
        return function (left, right) {
            return left[key].toLowerCase().localeCompare(right[key].toLowerCase(), undefined, compareOptions);
        };
    }
    if (descending) {
        return function (left, right) {
            return right.toLowerCase().localeCompare(left.toLowerCase(), undefined, compareOptions);
        };
    }
    return function (left, right) {
        return left.toLowerCase().localeCompare(right.toLowerCase(), undefined, compareOptions);
    };
}
/**
 * Sort an array by primitive values
 */
export function sortByPrimitive(key, descending) {
    if (descending === void 0) { descending = false; }
    var firstComparator = descending ? 1 : -1;
    var secondComparator = descending ? -1 : 1;
    if (key) {
        return function (left, right) {
            if (left[key] === right[key]) {
                return 0;
            }
            return left[key] < right[key] ? firstComparator : secondComparator;
        };
    }
    return function (left, right) {
        if (left === right) {
            return 0;
        }
        return left < right ? firstComparator : secondComparator;
    };
}
/**
 * Basic sort comparator
 */
export function sortComparator(left, right) {
    if (left < right) {
        return -1;
    }
    if (left > right) {
        return 1;
    }
    return 0;
}
export function splitIntoChunks(input, chunkSize) {
    if (chunkSize === void 0) { chunkSize = 25; }
    if (!is.array(input)) {
        throw new TypeError('expected an array for the first argument');
    }
    var chunks = [];
    for (var index = 0; index < Math.ceil(input.length / chunkSize); index++) {
        chunks.push(input.slice(index * chunkSize, (index + 1) * chunkSize));
    }
    return chunks;
}
//# sourceMappingURL=arrays.js.map