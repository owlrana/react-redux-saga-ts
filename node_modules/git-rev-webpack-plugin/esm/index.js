import { runGit } from './utils';
function GitRevPlugin(options) {
    if (options === void 0) { options = {}; }
    this.path = options.path;
    this.branchCommand = options.branchCommand || 'rev-parse --abbrev-ref HEAD';
    this.hashCommand = options.hashCommand || 'rev-parse --short HEAD';
    this.tagCommand = options.tagCommand || 'describe --abbrev=0 --tags';
}
GitRevPlugin.prototype.apply = function apply(compiler) {
    var REGEXP_BRANCH = /\[git-branch\]/gi;
    var REGEXP_HASH = /\[git-hash\]/gi;
    var REGEXP_TAG = /\[git-tag\]/gi;
    var currentBranch = runGit(this.path, this.branchCommand);
    var currentHash = runGit(this.path, this.hashCommand);
    var currentTag = runGit(this.path, this.tagCommand);
    compiler.hooks.compilation.tap('compilation', function (compilation) {
        /* istanbul ignore  else */
        if (typeof compilation.hooks.processAssets !== 'undefined') {
            compilation.hooks.assetPath.tap('asset-path', function (path) {
                return path
                    .replace(REGEXP_BRANCH, currentBranch)
                    .replace(REGEXP_HASH, currentHash)
                    .replace(REGEXP_TAG, currentTag);
            });
        }
        else {
            /* istanbul ignore next */
            compilation.mainTemplate.hooks.assetPath.tap('asset-path', function (path) {
                return path
                    .replace(REGEXP_BRANCH, currentBranch)
                    .replace(REGEXP_HASH, currentHash)
                    .replace(REGEXP_TAG, currentTag);
            });
        }
    });
};
GitRevPlugin.prototype.branch = function branch() {
    return runGit(this.path, this.branchCommand);
};
GitRevPlugin.prototype.hash = function hash(long) {
    if (long === void 0) { long = false; }
    return runGit(this.path, long ? this.hashCommand.replace(' --short', '') : this.hashCommand);
};
GitRevPlugin.prototype.tag = function tag() {
    return runGit(this.path, this.tagCommand);
};
export default GitRevPlugin;
//# sourceMappingURL=index.js.map